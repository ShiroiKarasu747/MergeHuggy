!function(){if(window.pc={markPhysics2dModuleAsUsed(){},markPhysics3dModuleAsUsed(){}},!DEVELOP)return;const s={Physics3d:"physics3d",Physics2d:"physics2d",ParticleSystem:"particle-system",Reflection:"reflection",Prefabs:"prefabs"};const e=new class{constructor(){this.classes=new Map,this.methods=new Map,this.unusedModules=new Set([s.Physics3d,s.Physics2d,s.ParticleSystem,s.Reflection,s.Prefabs]),this.saveTimerId=null,this.allClassesAreDefined=!1,window.addEventListener("luna:starting",(()=>{this.allClassesAreDefined=!0}))}registerClass(s){this.classes.has(s)||(this.classes.set(s,!0),this.save())}markClassAsUsed(s){this.classes.has(s)&&!1!==this.classes.get(s)&&(this.classes.set(s,!1),this.save())}registerMethod(s,e){this.methods.has(s)||this.methods.set(s,new Map);const t=this.methods.get(s);t.has(e)||(t.set(e,!0),this.save())}markMethodAsUsed(s,e){this.methods.has(s)||this.methods.set(s,new Map);const t=this.methods.get(s);!1!==t.get(e)&&(t.set(e,!1),this.save())}markModuleAsUsed(s){this.unusedModules.has(s)&&(this.unusedModules.delete(s),this.save())}serialize(){const s=new Set(window.$environment.forceIncludedClasses),e=[...this.classes.entries()].filter((([s,e])=>e)).filter((([e])=>!s.has(e))).map((([s])=>({name:s,excluded:!0}))),t=[];for(const i of this.methods.keys()){if(!0===this.classes.get(i))continue;if(s.has(i))continue;const n=[...this.methods.get(i).entries()].map((([s,e])=>({name:s,excluded:e})));0===n.length&&e.push({name:i,excluded:!1}),t.push({className:i,staticMethods:[],instanceMethods:n})}for(const[t,i]of this.classes.entries()){const n=!i&&!this.methods.has(t),r=s.has(t);(n||r)&&e.push({name:t,excluded:!1})}return JSON.stringify({unusedClasses:e,unusedMethods:t,unusedModules:[...this.unusedModules]})}save(){this.saveTimerId&&clearTimeout(this.saveTimerId),this.saveTimerId=setTimeout((()=>{this.saveTimerId=null,this.allClassesAreDefined?fetch(window.location.origin+"/tracing",{method:"POST",body:this.serialize()}):this.save()}),100)}};window.traceResults=e,e.EngineModules=s;const t=new Set;function i(s){if(!s)return null;const e=s.$$fullname||s.$$name;return e?e.replace("+","."):null}function n(s,t,n){!Bridge.Class.$queue.includes(s)&&s.prototype&&Bridge.Class.$queue.push(s),e.markClassAsUsed(t);const r=[];s.$$inherits&&s.$$inherits.forEach((function s(e){n.has(e)||(n.add(e),e.$$inherits&&e.$$inherits.forEach(s),e.$genericTypeDefinition?(s(e.$genericTypeDefinition),e.$typeArguments.forEach(s)):r.push(i(e)))})),r.filter((s=>s)).forEach((s=>e.markClassAsUsed(s)))}window.TRACE=(s,i)=>{if(Array.isArray(s))for(let t=0;t<s.length;t++){const i=s[t],[n,...r]=i.split("#");e.registerClass(n),e.registerMethod(n,r.join("#"))}else{if(t.has(s))return;t.add(s);const[i,...n]=s.split("#");e.markClassAsUsed(i),e.markMethodAsUsed(i,n.join("#"))}};const r=/TRACE\(\s*"(.+)"/;let a=null;Object.defineProperty(window,"Bridge",{get:()=>a,set(s){if(a===s)return;!function(s){let t=null;const r=function(r,a,o,h){return!(o||a&&a.$noRegister)&&e.registerClass(r),a?t.call(s,r,"function"==typeof a?function(s,e){const t=function(...t){const r=new Set,a=e(...t);return n({},s,r),t.forEach((s=>n(s,i(s),r))),Array.isArray(a.inherits)&&a.inherits.forEach((s=>n(s,i(s),r))),a};return Object.defineProperty(t,"length",{get:()=>e.length}),t.toString=()=>e.toString(),t.$aliasInit=e.$aliasInit,t}(r,a):function(s,e){let t=e.statics||e.$statics;t||(t={},e.statics=t),["fields","events","props","ctors","methods"].some((s=>s in t))&&(t.ctors=t.ctors||{},t=t.ctors);let i=t.ctor;return i||(i=()=>{},t.ctor=i),t.ctor=function(...e){const t=new Set;n(this,s,t),i.apply(this,e)},e}(r,a),o,h):t.call(s,r,a,o,h)};Object.defineProperty(s,"define",{get:()=>r,set(s){t=s}})}(s);const t=s.fn.cacheBind;s.fn.cacheBind=(s,e,i,n)=>{const a=function(s){const e=s.toString().match(r);return e&&e[1]?e[1]:null}(e);return a&&TRACE(a),t(s,e,i,n)},a=s}})}(),function(){if(!DEVELOP)return;window.shaderVariantsTraceResults=new class{constructor(){this.shaderVariants=new Map,this.saveTimerId=null}registerShaderVariant(s){const e=this.shaderVariants;e.has(s.id)||(e.set(s.id,s),this.save())}hasShaderVariant(s){return this.shaderVariants.has(s)}serialize(){const s=Array.from(this.shaderVariants.values());return JSON.stringify({variants:s})}save(){this.saveTimerId&&clearTimeout(this.saveTimerId),this.saveTimerId=setTimeout((()=>{fetch(window.location.origin+"/tracing/shader/variants",{method:"POST",body:this.serialize()})}),250)}}}();